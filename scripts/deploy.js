// scripts/deploy-with-emojis.js
const { ethers } = require("hardhat");
const fs = require("node:fs");
const path = require("node:path");

async function main() {
	console.log("üöÄ Starting deployment process...");

	// Get network information
	const network = await ethers.provider.getNetwork();
	const networkName = network.name;
	const isTestnet =
		networkName.includes("testnet") || networkName === "hyperliquid_testnet";
	const configPrefix = isTestnet ? "TESTNET" : "MAINNET";

	console.log(
		`üåê Deploying to ${networkName} (${
			isTestnet ? "üß™ Testnet" : "üî¥ Mainnet"
		})`,
	);
	console.log(`‚õìÔ∏è Chain ID: ${network.chainId}`);

	// Load configuration based on network
	const hyperFrogsV2Address =
		process.env[`${configPrefix}_HYPERFROGS_V2_ADDRESS`];
	const unmigratedClaimAddress =
		process.env[`${configPrefix}_UNMIGRATED_CLAIM_ADDRESS`];
	const existingDistributorAddress =
		process.env[`${configPrefix}_DISTRIBUTOR_ADDRESS`];
	const existingPondCoreAddress =
		process.env[`${configPrefix}_POND_CORE_ADDRESS`];
	const createStandardPonds =
		process.env[`${configPrefix}_CREATE_STANDARD_PONDS`] === "true";

	// Handle decimal conversion more safely for ETH amounts
	let minTossPrice;
	let maxTotalTossAmount;
	try {
		minTossPrice = ethers.parseEther(
			process.env[`${configPrefix}_MIN_TOSS_PRICE`],
		);
		maxTotalTossAmount = ethers.parseEther(
			process.env[`${configPrefix}_MAX_TOTAL_TOSS_AMOUNT`],
		);
	} catch (error) {
		console.error("‚ö†Ô∏è Error parsing ETH amounts, using defaults");
		minTossPrice = ethers.parseEther("0.0001");
		maxTotalTossAmount = ethers.parseEther("10");
	}

	const minFrogsRequired = Number.parseInt(
		process.env[`${configPrefix}_MIN_FROGS_REQUIRED`] || "5",
	);
	const selectionTimelock = Number.parseInt(
		process.env[`${configPrefix}_SELECTION_TIMELOCK`] || "60",
	);
	const feePercentage = Number.parseInt(
		process.env[`${configPrefix}_FEE_PERCENTAGE`] || "7",
	);

	// Validate key configuration
	if (!hyperFrogsV2Address)
		throw new Error(`‚ùå Missing ${configPrefix}_HYPERFROGS_V2_ADDRESS`);
	if (!unmigratedClaimAddress)
		throw new Error(`‚ùå Missing ${configPrefix}_UNMIGRATED_CLAIM_ADDRESS`);

	console.log("üìã Configuration loaded:");
	console.log(`- üê∏ HyperFrogs V2: ${hyperFrogsV2Address}`);
	console.log(`- üè¶ Unmigrated Claim Address: ${unmigratedClaimAddress}`);
	console.log(`- üí∞ Min Toss Price: ${ethers.formatEther(minTossPrice)} ETH`);
	console.log(
		`- üí∏ Max Total Toss Amount: ${ethers.formatEther(maxTotalTossAmount)} ETH`,
	);
	console.log(`- üî¢ Min Frogs Required: ${minFrogsRequired}`);
	console.log(`- ‚è±Ô∏è Selection Timelock: ${selectionTimelock} seconds`);
	console.log(`- üíπ Fee Percentage: ${feePercentage}%`);
	console.log(
		`- üåä Create Standard Ponds: ${createStandardPonds ? "‚úÖ Yes" : "‚ùå No"}`,
	);

	if (existingDistributorAddress) {
		console.log(
			`- üíº Using existing Distributor: ${existingDistributorAddress}`,
		);
	}

	if (existingPondCoreAddress) {
		console.log(`- üåü Using existing PondCore: ${existingPondCoreAddress}`);
	}

	// Get deployer account
	const [deployer] = await ethers.getSigners();
	console.log(`üë®‚Äçüíª Deploying with account: ${deployer.address}`);

	// Check deployer balance
	const deployerBalance = await ethers.provider.getBalance(deployer.address);
	console.log(
		`üíé Deployer balance: ${ethers.formatEther(deployerBalance)} ETH`,
	);

	// Define gas limits for complex contracts (customize as needed)
	const GAS_LIMITS = {
		FEE_DISTRIBUTOR: 10000000,
		POND_CORE: 15000000,
		POND_FACTORY: 15000000,
		GRANT_ROLE: 10000000,
		CREATE_PONDS: 20000000,
	};

	console.log("\n‚õΩ Using gas limits:");
	for (const [contract, limit] of Object.entries(GAS_LIMITS)) {
		console.log(`- ${contract}: ${limit.toLocaleString()} gas`);
	}

	const deploymentInfo = {
		network: networkName,
		chainId: Number(network.chainId),
		deployer: deployer.address,
		timestamp: new Date().toISOString(),
		hyperFrogsV2: hyperFrogsV2Address,
		unmigratedClaimAddress: unmigratedClaimAddress,
	};

	try {
		// Determine fee distributor address - use existing or deploy new
		let feeDistributorAddress;

		if (
			existingDistributorAddress &&
			ethers.isAddress(existingDistributorAddress)
		) {
			console.log("\nüîÑ Using existing PondFeeDistributor from .env file");
			feeDistributorAddress = existingDistributorAddress;
			deploymentInfo.pondFeeDistributor = feeDistributorAddress;
			console.log(`üìç PondFeeDistributor address: ${feeDistributorAddress}`);

			// Verify the contract exists
			try {
				const code = await ethers.provider.getCode(feeDistributorAddress);
				if (code === "0x") {
					console.warn(
						`‚ö†Ô∏è WARNING: No contract code found at the provided distributor address: ${feeDistributorAddress}`,
					);
					console.warn(
						"Will continue anyway, but this might cause issues later.",
					);
				} else {
					console.log("‚úÖ Contract verified at address");
				}
			} catch (error) {
				console.warn(
					`‚ö†Ô∏è WARNING: Error checking contract code at distributor address: ${error.message}`,
				);
			}
		} else {
			// 1. Deploy PondFeeDistributor first
			console.log("\n1Ô∏è‚É£ Deploying PondFeeDistributor...");

			const gasReserve = ethers.parseEther("0.01"); // Reserve 0.01 ETH for gas
			const initialClaimPeriod = 7 * 24 * 60 * 60; // 7 days in seconds

			// Log contract parameters for debugging
			console.log("üìù PondFeeDistributor constructor parameters:");
			console.log(`- üê∏ NFT Contract: ${hyperFrogsV2Address}`);
			console.log(`- üè¶ Project Wallet: ${unmigratedClaimAddress}`);
			console.log(`- ‚õΩ Gas Reserve: ${ethers.formatEther(gasReserve)} ETH`);
			console.log(`- üî¢ Min NFTs Required: ${minFrogsRequired}`);
			console.log(`- ‚è±Ô∏è Initial Claim Period: ${initialClaimPeriod} seconds`);

			const PondFeeDistributor =
				await ethers.getContractFactory("PondFeeDistributor");

			// Deploy with high gas limit
			const feeDistributor = await PondFeeDistributor.deploy(
				hyperFrogsV2Address,
				unmigratedClaimAddress,
				gasReserve,
				minFrogsRequired,
				initialClaimPeriod,
				{ gasLimit: GAS_LIMITS.FEE_DISTRIBUTOR },
			);

			console.log(
				`üì§ PondFeeDistributor deployment transaction sent: ${
					feeDistributor.deploymentTransaction().hash
				}`,
			);
			await feeDistributor.waitForDeployment();
			feeDistributorAddress = await feeDistributor.getAddress();

			console.log(
				`üéâ PondFeeDistributor deployed to: ${feeDistributorAddress}`,
			);
			deploymentInfo.pondFeeDistributor = feeDistributorAddress;
		}

		// Determine PondCore address - use existing or deploy new
		let pondCoreAddress;

		if (existingPondCoreAddress && ethers.isAddress(existingPondCoreAddress)) {
			console.log("\nüîÑ Using existing PondCore from .env file");
			pondCoreAddress = existingPondCoreAddress;
			deploymentInfo.pondCore = pondCoreAddress;
			console.log(`üìç PondCore address: ${pondCoreAddress}`);

			// Verify the contract exists
			try {
				const code = await ethers.provider.getCode(pondCoreAddress);
				if (code === "0x") {
					console.warn(
						`‚ö†Ô∏è WARNING: No contract code found at the provided PondCore address: ${pondCoreAddress}`,
					);
					console.warn(
						"Will continue anyway, but this might cause issues later.",
					);
				} else {
					console.log("‚úÖ Contract verified at address");
				}
			} catch (error) {
				console.warn(
					`‚ö†Ô∏è WARNING: Error checking contract code at PondCore address: ${error.message}`,
				);
			}

			// Get the PondCore contract instance
			const pondCore = await ethers.getContractAt("PondCore", pondCoreAddress);

			// Verify key parameters
			try {
				const actualFeeAddress = await pondCore.feeAddress();
				if (
					actualFeeAddress.toLowerCase() !== feeDistributorAddress.toLowerCase()
				) {
					console.warn(
						`‚ö†Ô∏è WARNING: PondCore fee address (${actualFeeAddress}) does not match provided distributor address (${feeDistributorAddress})`,
					);
				} else {
					console.log("‚úÖ PondCore fee address matches distributor address");
				}
			} catch (error) {
				console.warn(
					`‚ö†Ô∏è WARNING: Error verifying PondCore parameters: ${error.message}`,
				);
			}
		} else {
			// 2. Deploy PondCore using PondFeeDistributor as fee address
			console.log("\n2Ô∏è‚É£ Deploying PondCore...");
			console.log("üìù PondCore constructor parameters:");
			console.log(`- üíº Fee Address: ${feeDistributorAddress}`);
			console.log(`- üíπ Fee Percentage: ${feePercentage}`);
			console.log(`- ‚è±Ô∏è Selection Timelock: ${selectionTimelock} seconds`);

			const PondCore = await ethers.getContractFactory("PondCore");

			// Deploy with high gas limit for complex contract
			const pondCore = await PondCore.deploy(
				feeDistributorAddress,
				feePercentage,
				selectionTimelock,
				{ gasLimit: GAS_LIMITS.POND_CORE },
			);

			console.log(
				`üì§ PondCore deployment transaction sent: ${
					pondCore.deploymentTransaction().hash
				}`,
			);
			await pondCore.waitForDeployment();
			pondCoreAddress = await pondCore.getAddress();

			console.log(`üéâ PondCore deployed to: ${pondCoreAddress}`);
			deploymentInfo.pondCore = pondCoreAddress;
		}

		// 3. Deploy PondFactory
		console.log("\n3Ô∏è‚É£ Deploying PondFactory...");
		console.log("üìù PondFactory constructor parameters:");
		console.log(`- üåü PondCore Address: ${pondCoreAddress}`);

		try {
			const PondFactory = await ethers.getContractFactory("PondFactory");

			const pondFactory = await PondFactory.deploy(pondCoreAddress, {
				gasLimit: GAS_LIMITS.POND_FACTORY,
			});

			console.log(
				`üì§ PondFactory deployment transaction sent: ${
					pondFactory.deploymentTransaction().hash
				}`,
			);
			await pondFactory.waitForDeployment();
			const pondFactoryAddress = await pondFactory.getAddress();

			console.log(`üéâ PondFactory deployed to: ${pondFactoryAddress}`);
			deploymentInfo.pondFactory = pondFactoryAddress;

			// Get the PondCore contract instance
			const pondCore = await ethers.getContractAt("PondCore", pondCoreAddress);

			// 4. Grant FACTORY_ROLE to PondFactory
			console.log("\n4Ô∏è‚É£ Setting up roles...");

			const factoryRole = await pondCore.FACTORY_ROLE();
			console.log(`üîë Factory role hash: ${factoryRole}`);

			// Grant role with high gas limit
			const tx1 = await pondCore.grantRole(factoryRole, pondFactoryAddress, {
				gasLimit: GAS_LIMITS.GRANT_ROLE,
			});

			console.log(`üì§ Role grant transaction sent: ${tx1.hash}`);
			await tx1.wait();

			console.log(
				`‚úÖ Granted FACTORY_ROLE to PondFactory: ${pondFactoryAddress}`,
			);

			// 5. Save deployment information
			const deployDir = path.join(__dirname, "../deployments");
			if (!fs.existsSync(deployDir)) {
				fs.mkdirSync(deployDir, { recursive: true });
			}

			const timestamp = Math.floor(Date.now() / 1000);
			const deploymentPath = path.join(
				deployDir,
				`${networkName}_${timestamp}.json`,
			);

			fs.writeFileSync(deploymentPath, JSON.stringify(deploymentInfo, null, 2));
			console.log(`\nüíæ Deployment information saved to: ${deploymentPath}`);

			// Output important addresses
			console.log("\n=== üöÄ DEPLOYMENT SUMMARY üöÄ ===");
			console.log(`üåê Network: ${networkName}`);
			console.log(`üíº PondFeeDistributor: ${feeDistributorAddress}`);
			console.log(`üåü PondCore: ${pondCoreAddress}`);
			if (deploymentInfo.pondFactory) {
				console.log(`üè≠ PondFactory: ${deploymentInfo.pondFactory}`);
			} else {
				console.log("üî¥ PondFactory: DEPLOYMENT FAILED");
			}
			console.log("==========================");

			// Update the .env file with the deployed contract addresses
			console.log("\nüìù Update your .env file with these values:");
			if (!existingDistributorAddress) {
				console.log(
					`${configPrefix}_DISTRIBUTOR_ADDRESS=${feeDistributorAddress}`,
				);
			}
			if (!existingPondCoreAddress) {
				console.log(`${configPrefix}_POND_CORE_ADDRESS=${pondCoreAddress}`);
			}
			if (deploymentInfo.pondFactory) {
				console.log(
					`${configPrefix}_POND_FACTORY_ADDRESS=${deploymentInfo.pondFactory}`,
				);
			}
		} catch (error) {
			console.error("\n‚ùå Error during deployment:");
			console.error(error);

			// Try to get more detailed error information
			if (error.transaction) {
				console.log("\nüîç Transaction that caused the error:");
				console.log(error.transaction);

				try {
					// Try to get transaction receipt for more details
					const receipt = await ethers.provider.getTransactionReceipt(
						error.transactionHash,
					);
					console.log("\nüßæ Transaction receipt:");
					console.log(receipt);
				} catch (receiptError) {
					console.log(
						"‚ùå Could not get transaction receipt:",
						receiptError.message,
					);
				}
			}

			// Save partial deployment info
			const deployDir = path.join(__dirname, "../deployments");
			if (!fs.existsSync(deployDir)) {
				fs.mkdirSync(deployDir, { recursive: true });
			}

			const timestamp = Math.floor(Date.now() / 1000);
			const deploymentPath = path.join(
				deployDir,
				`${networkName}_${timestamp}_partial.json`,
			);

			deploymentInfo.error = {
				message: error.message,
				stack: error.stack,
			};

			fs.writeFileSync(deploymentPath, JSON.stringify(deploymentInfo, null, 2));
			console.log(
				`\nüíæ Partial deployment information saved to: ${deploymentPath}`,
			);

			throw error;
		}
		// 5. Create standard ponds if enabled
		if (createStandardPonds) {
			console.log("\n5Ô∏è‚É£ Creating standard ponds...");

			// Define pond periods to create (all standard periods)
			const pondPeriods = [0, 1, 2, 3, 4]; // Five-min, Hourly, Daily, Weekly, Monthly

			// Create native ETH ponds
			console.log("üåä Creating native ETH ponds...");

			try {
				// Create ponds with high gas limit
				const tx2 = await pondFactory.createStandardPonds(
					ethers.ZeroAddress, // Native ETH
					"ETH",
					minTossPrice,
					maxTotalTossAmount,
					pondPeriods,
					{
						gasLimit: GAS_LIMITS.CREATE_PONDS,
					},
				);

				console.log(`üì§ Create standard ponds transaction sent: ${tx2.hash}`);
				await tx2.wait();
				console.log("‚úÖ ETH ponds created successfully");
			} catch (error) {
				console.error(`‚ùå Failed to create ETH ponds: ${error.message}`);
				// Continue with other tokens even if ETH ponds fail
			}

			// Create ERC20 token ponds if any tokens are specified
			const defaultTokensEnv = process.env[`${configPrefix}_DEFAULT_TOKENS`];
			if (defaultTokensEnv) {
				const defaultTokens = defaultTokensEnv.split(",");
				console.log(
					`ü™ô Found ${defaultTokens.length} tokens to set up ponds for`,
				);

				for (const tokenAddress of defaultTokens) {
					// Get token symbol (try with error handling)
					let symbol = "TOKEN";
					try {
						const tokenContract = await ethers.getContractAt(
							"IERC20Metadata",
							tokenAddress,
						);
						symbol = await tokenContract.symbol();
					} catch (error) {
						console.warn(
							`‚ö†Ô∏è Could not get symbol for token ${tokenAddress}, using default`,
						);
					}

					console.log(`ü™ô Creating ponds for ${symbol} (${tokenAddress})...`);

					try {
						// Register token with high gas limit
						const tx3 = await pondFactory.addSupportedToken(
							tokenAddress,
							symbol,
							{
								gasLimit: GAS_LIMITS.GRANT_ROLE,
							},
						);

						console.log(`üì§ Register token transaction sent: ${tx3.hash}`);
						await tx3.wait();

						// Create token ponds with high gas limit
						const tx4 = await pondFactory.createStandardPonds(
							tokenAddress,
							symbol,
							minTossPrice,
							maxTotalTossAmount,
							pondPeriods,
							{
								gasLimit: GAS_LIMITS.CREATE_PONDS,
							},
						);

						console.log(`üì§ Create token ponds transaction sent: ${tx4.hash}`);
						await tx4.wait();
						console.log(`‚úÖ ${symbol} ponds created successfully`);
					} catch (error) {
						console.error(
							`‚ùå Failed to create ponds for ${symbol}: ${error.message}`,
						);
						// Continue with other tokens
					}
				}
			}
		}
	} catch (factoryError) {
		console.error(`‚ùå PondFactory deployment failed: ${factoryError.message}`);
		console.error(factoryError);

		// Still save the partial deployment info
		deploymentInfo.factoryError = {
			message: factoryError.message,
			stack: factoryError.stack,
		};
	}
}

main()
	.then(() => process.exit(0))
	.catch((error) => {
		console.error("‚ùå Deployment error:", error);
		process.exit(1);
	});
